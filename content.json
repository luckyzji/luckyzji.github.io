{"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"关于我","text":"学校：西安电子科技大学状态：大三在读Java、啥也不会、整天摸鱼","link":"/about/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"快速幂","text":"快速幂通常情况求，我们求ab都习惯按照如下方式做： 12345678910111213141516#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;int myPow(int a,int b){ int res=1; for(int i=0;i&lt;b;i++){ res*=a; } return res;}int main(){ int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;pow(a,b)&lt;&lt;endl;//直接调用pow()函数 cout&lt;&lt;myPow(a,b)&lt;&lt;endl;//自定义myPow()函数} 但是，这样做，在做比较大的求幂时，可能花的时间会比较多，我们有没有更快的方法呢？当然有，我们接着往下看。比如在求210,我们可以转换成求25*25的形式，这样就比直接求10次快。快速幂就是用的这种思路。我们都知道，数字以二进制的方式存储在计算机中，比如10=(1010)2，所以我们在求幂的时候，可以考二进制。我们看代码 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;int fast_pow(int a,int b){ int res=1; while(b){ if(b&amp;1){ //b的二进制最低位与1算数与。 res=res*a; } b&gt;&gt;=1; //b右移一位。 a=a*a; //b每右移一位，a就翻一倍。 /*如2的10次幂 10=（1010)2 *1）0&amp;1=0; b=101;a=a*a=4; *2）1&amp;1=1;res=res*a=4;b=10;a=a*a=16; *3）0&amp;1=0;b=1;a=a*a=256; *4）1&amp;1=1;res=res*a=1024;b=0(退出循环)。 */ } return res;}int main(){ int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;fast_pow(a,b)&lt;&lt;endl;} 从这上面的例子，我们可以看出快速幂能使求幂的的效率高不少。接下来我们看一个快速幂的例子：原题链接：XDOJ1027题目：北雷老中医不懂 Fibonacci，于是他定义了一种名叫Feibonaqi的数列，数列满足以下要求：1.f(0)=0,f(1)=12.f(n)=2f(n-1)+f(n-2),n&gt;1那么问题来了，这个数列的第n项是多少呢？（不为难大家用高精度了，你只需要将结果对1,000,000,007取模后输出即可）输入：多组数据每组数据一行，包含一个整数n，1&lt;n&lt;1,000,000,000输出：每组数据输出一个整数，即为f(n)对1,000,000,007取模后的结果分析：从题目中可以看出，数据范围比较大，如果是用递归或者递推方式写，肯定会超时，所以我们应该要考虑其他的方法。我们就可以考虑快速幂的方法。不过，这道题要用到矩阵乘法，用矩阵快速幂。代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#define MOD 1000000007using namespace std;typedef long long ll;struct matrix{ ll m[3][3];}Mat,unit;ll a[3]={0,1,2};matrix multi(matrix a,matrix b){ matrix res; ll x; ll i,j,k; for(i=0;i&lt;3;i++){ for(j=0;j&lt;3;j++){ x=0; for(k=0;k&lt;3;k++){ x=(x+((ll)a.m[i][k]*(ll)b.m[k][j]))%MOD; } res.m[i][j]=x%MOD; } } return res;}void Init(){ Mat.m[0][0]=2;Mat.m[0][1]=1;Mat.m[0][2]=0; Mat.m[1][0]=1;Mat.m[1][1]=0;Mat.m[1][2]=1; Mat.m[2][0]=0;Mat.m[2][1]=0;Mat.m[2][2]=0; for(int i=0;i&lt;3;i++){ unit.m[i][i]=1; }}matrix pow_matrix(matrix a,ll n){ matrix res=unit; while(n){ if(n&amp;1)res=multi(res,a); a=multi(a,a); n=n&gt;&gt;1; } return res;}ll Feibonaqi(ll n){ if(n==0)return a[0]; if(n==1)return a[1]; if(n==2)return a[2]; matrix res=pow_matrix(Mat,n-2); return (a[2]*res.m[0][0]+a[1]*res.m[1][0])%MOD;}int main(){ Init(); ll n; while(cin&gt;&gt;n){ cout&lt;&lt;Feibonaqi(n)&lt;&lt;endl; }} a2 a1 a0=[ 2 , 1 , 0 ]，Feibonaqi前三项Mat:根据Feibonaqi推出的矩阵(可以写成2X2的矩阵，a也可以改成1X2的) 2 1 0 1 0 0 0 0 0 a*Matn-2得到的一行三列的矩阵的第0项就是要求的值","link":"/2020/05/01/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"title":"排序算法","text":"排序算法1、冒泡排序：冒泡排序就像它名字一样，冒泡，就像水里的气泡一样往上冒，通过多次冒泡，可以把小的往前，也可把大的往后，使得一组数据大小有序排列，举个例子：待排 ：4 3 2 5 1 3 2 4 1 5 2 3 1 4 5 2 1 3 4 5 1 2 3 4 5 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;void sort(int a[],int n)//冒泡{ int i,j; for(i=0;i&lt;n;i++) //此循环执行n次，依次将最大数，次大数······放到后面，从而实现从小到大排序 { for(j=0;j&lt;n-i-1;j++) //此循环将较大的数放到后面，大数就像冒泡一样往后冒 { if(a[j]&gt;a[j+1]) { int temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; } } }}int main(){ int n,i; scanf(\"%d\",&amp;n); int a[n]; for(i=0;i&lt;n;i++) { scanf(\"%d\",&amp;a[i]); } sort(a,n); for(i=0;i&lt;n;i++) { printf(\"%d \",a[i]); } return 0;} 测试 2、选择排序：选择排序是每次通过循环比较后，记下最大或者最小数的位置，然后交换。举个例子：4 3 2 5 1（记下最小数位置） 1 3 2 5 4 1最小，1和4交换 1 2 3 5 4 在后四个数中2最小，2和3交换 1 2 3 5 4 在后三个数中3最小，位置不变 1 2 3 4 5 在后两个数中4最小，4和5交换 代码：12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;void SelSort(int a[],int n)//选择{ int i,j; for(i=0;i&lt;n-1;i++) { int minIndex=i; for(j=i+1;j&lt;n;j++) { if(a[minIndex]&gt;a[j]) { minIndex=j; } } int temp=a[i]; a[i]=a[minIndex]; a[minIndex]=temp; }}int main(){ int n,i; scanf(\"%d\",&amp;n); int a[n]; for(i=0;i&lt;n;i++) { scanf(\"%d\",&amp;a[i]); } SelSort(a,n); for(i=0;i&lt;n;i++) { printf(\"%d \",a[i]); } return 0;} 测试 3、插入排序：插入排序，就像咱们斗地主一样，把大的放一边，小的放一边，摸起一张牌后，要找到适合它的位置插入。举个例子：4 3 2 5 1 4 3 2 5 1 只有4，位置不变 3 4 2 5 1 3比4小，插到四前面 2 3 4 5 1 2比3、4小，插到最前面 2 3 4 5 1 5比前面的数都大，不变 1 2 3 4 5 1最小，插到最前面注意：这里的插入是通过一个数一个数的移动完成的 代码：1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;void InsertSort(int a[],int n)//插入 { int i,j; for(i=1;i&lt;n;i++) { for(j=i-1;j&gt;=0&amp;&amp;a[j]&gt;a[j+1];j--)//寻找合适的插入位置，通过一个数一个数的移动完成的 { int temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; } }}int main(){ int n,i; scanf(\"%d\",&amp;n); int a[n]; for(i=0;i&lt;n;i++) { scanf(\"%d\",&amp;a[i]); } InsertSort(a,n); for(i=0;i&lt;n;i++) { printf(\"%d \",a[i]); } return 0;} 测试： 4、归并排序：归并排序涉及到递归（不懂得小伙伴自己去查查，自己调自己了）需要开辟一个辅助数组来存数据；每次归并一部分，慢慢扩大范围，使得整组数据有序。还是举个例子：4 3 2 5 1 被划分为 4 3 2 、5 1两部分 再划分 4 3 、 2 、 5、 1四部分 4 3再划分为 4 、3两部分 （实际上并不是这样，只是为了方便理解，实际是先把左边划分归并完后，再来划分归并右边的） 接下来开始归并 4 和 3归并 3小变成 3 4 3 4和2归并 2小变成 2 3 4 5和1 归并 变成 1 5 2 3 4和 1 5归并谁小谁放前面 1 2 3 4 5完成这个理解起来稍微复杂一点，但是他的时间复杂度比前三个都小。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;stdio.h&gt;void MergeSort(int a[],int L,int R)//归并排序{ if(L==R)return; int mid=(L+R)/2; MergeSort(a,L,mid); //对半分，先使得左边有序， MergeSort(a,mid+1,R); //再使得右边有序，最后使得整体有序 int temp[R-L+1]; //开一个辅助数组 int i=0; int p1=L,p2=mid+1; while(p1&lt;=mid&amp;&amp;p2&lt;=R) //归并过程 { temp[i++]=a[p1]&lt;a[p2]?a[p1++]:a[p2++]; //谁小把谁放进辅助数组 } while(p1&lt;=mid) //接下来这两个循环是把没归并完的数放入辅助数组 { temp[i++]=a[p1++]; } while(p2&lt;=R) { temp[i++]=a[p2++]; } for(i=0;i&lt;=R-L;i++) //把辅助数组的值复制给原数组 { a[L+i]=temp[i]; //printf(\"%d \",temp[i]); 此处可打印观看归并过程 } //printf(\"\\n\");}int main(){ int n,i; scanf(\"%d\",&amp;n); int a[n]; for(i=0;i&lt;n;i++) { scanf(\"%d\",&amp;a[i]); } MergeSort(a,0,n-1); for(i=0;i&lt;n;i++) { printf(\"%d \",a[i]); } return 0;} 测试： 这是我的第一篇博客，学习ing，如有不足，望多担待","link":"/2019/11/17/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%86%92%E6%B3%A1%E3%80%81%E9%80%89%E6%8B%A9%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E5%BD%92%E5%B9%B6%EF%BC%89/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序算法","slug":"排序算法","link":"/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}]}
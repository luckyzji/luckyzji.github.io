{"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"关于我","text":"学校：西安电子科技大学状态：大三在读Java、啥也不会、整天摸鱼","link":"/about/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"Binary Tree Traversal","text":"1. 递归方法 递归方法比较简单，不过多赘述，直接看代码： 1234567891011121314151617181920212223public class BinaryTreeTraversal { //先序遍历 public void preOrder(TreeNode root){ if(root==null)return; System.out.print(root.val+\" \"); preOrder(root.left); preOrder(root.right); } //中序遍历 public void midOrder(TreeNode root){ if(root==null)return; midOrder(root.left); System.out.print(root.val+\" \"); midOrder(root.right); } //后序遍历 public void postorder(TreeNode root){ if(root==null)return; postorder(root.left); postorder(root.right); System.out.print(root.val+\" \"); }} 2. 非递归方法非递归的方法，我们要做到多次访问一个节点，需要使用栈来保存之前的信息。递归的方法其实是系统为我们提供的函数栈，非递归则是我们自己用栈来模拟。 1). 先序遍历先序遍历的规律是：中左右，第一次访问到根节点的时候就打印。要实现这样的访问，我们先将根节点压栈，然后进入一个循环，循环条件是栈不空。然后从栈中弹出一个元素，打印它的值，然后先判断当前的元素是否有右节点，有就压栈；再判断是否有左节点，同样有就压栈。先压右节点再压左节点是为了先弹出左边的节点，再弹出右边的节点。代码如下: 123456789101112public void preOrderNonrecursive(TreeNode root){ if(root==null)return; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.isEmpty()){ TreeNode temp = stack.pop(); System.out.print(temp.val+\" \"); if(temp.right!=null)stack.push(temp.right); if(temp.left!=null)stack.push(temp.left); } System.out.println(); } 2). 中序遍历中序遍历的规律：左中右，当第二次访问到该节点时才打印。要实现这样的访问，我们在压栈时，如果当前节点有左孩子，我们就把左孩子压栈，直到左孩子为空；然后从栈顶弹出一个元素打印，然后判断弹出的元素是否有右孩子，有就把右孩子压栈，然后弹出一个元素，判断是否有左孩子…重复这个循环。代码如下： 1234567891011121314151617public void midOrderNonrecursive(TreeNode root){ if(root==null)return; Stack&lt;TreeNode&gt; stack =new Stack&lt;&gt;(); TreeNode tempNode = root; while(!stack.isEmpty()||tempNode!=null){ if(tempNode!=null){ stack.push(tempNode); tempNode=tempNode.left; } else{ tempNode=stack.pop(); System.out.print(tempNode.val+\" \"); tempNode= tempNode.right; } } System.out.println(); } 3). 后序遍历后序遍历的规律：左右中，当第三次访问到该节点时才打印。为了实现这个访问顺序，我们可以先实现 中右左 的访问，然后再把这个访问顺序反过来就是 左右中 的访问，因此，我们可以准备两个栈，其中一个栈用来实现 中右左的访问(参照先序遍历，这次只改为先压左孩子，再压有孩子)，另外一个栈用来存储访问顺序，最后弹栈打印。代码如下： 12345678910111213141516public void postorderNonrecursive(TreeNode root){ if(root==null)return; Stack&lt;TreeNode&gt; stack1 = new Stack&lt;&gt;(); Stack&lt;TreeNode&gt; stack2 = new Stack&lt;&gt;(); stack1.push(root); while(!stack1.isEmpty()){ TreeNode tempNode = stack1.pop(); stack2.push(tempNode); if(tempNode.left!=null)stack1.push(tempNode.left); if(tempNode.right!=null)stack1.push(tempNode.right); } while(!stack2.isEmpty()){ System.out.print(stack2.pop().val+\" \"); } System.out.println(); } 上面是用两个栈来实现的，还可以用一个栈来实现，代码如下： 12345678910111213141516171819public void postorderNonrecursiveOnlyOneStack(TreeNode root){ if(root==null)return; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); TreeNode tempNode = null; while(!stack.isEmpty()){ tempNode = stack.peek(); if(tempNode.left!=null&amp;&amp;root!=tempNode.left&amp;&amp;root!=tempNode.right){//复用root来标记左孩子和右孩子是否被访问过 stack.push(tempNode.left); } else if(tempNode.right!=null&amp;&amp;root!=tempNode.right){ stack.push(tempNode.right); } else{ System.out.print(stack.pop().val+\" \"); root=tempNode;//复用root来标记左孩子和右孩子是否被访问过 } } }","link":"/2020/09/27/BinaryTreeTraversal/"},{"title":"快速幂","text":"通常情况求，我们求ab都习惯按照如下方式做： 12345678910111213141516#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;int myPow(int a,int b){ int res=1; for(int i=0;i&lt;b;i++){ res*=a; } return res;}int main(){ int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;pow(a,b)&lt;&lt;endl;//直接调用pow()函数 cout&lt;&lt;myPow(a,b)&lt;&lt;endl;//自定义myPow()函数} 但是，这样做，在做比较大的求幂时，可能花的时间会比较多，我们有没有更快的方法呢？当然有，我们接着往下看。比如在求210,我们可以转换成求25*25的形式，这样就比直接求10次快。快速幂就是用的这种思路。我们都知道，数字以二进制的方式存储在计算机中，比如10=(1010)2，所以我们在求幂的时候，可以考二进制。我们看代码 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;int fast_pow(int a,int b){ int res=1; while(b){ if(b&amp;1){ //b的二进制最低位与1算数与。 res=res*a; } b&gt;&gt;=1; //b右移一位。 a=a*a; //b每右移一位，a就翻一倍。 /*如2的10次幂 10=（1010)2 *1）0&amp;1=0; b=101;a=a*a=4; *2）1&amp;1=1;res=res*a=4;b=10;a=a*a=16; *3）0&amp;1=0;b=1;a=a*a=256; *4）1&amp;1=1;res=res*a=1024;b=0(退出循环)。 */ } return res;}int main(){ int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;fast_pow(a,b)&lt;&lt;endl;} 从这上面的例子，我们可以看出快速幂能使求幂的的效率高不少。接下来我们看一个快速幂的例子：原题链接：XDOJ1027题目：北雷老中医不懂 Fibonacci，于是他定义了一种名叫Feibonaqi的数列，数列满足以下要求：1.f(0)=0,f(1)=12.f(n)=2f(n-1)+f(n-2),n&gt;1那么问题来了，这个数列的第n项是多少呢？（不为难大家用高精度了，你只需要将结果对1,000,000,007取模后输出即可）输入：多组数据每组数据一行，包含一个整数n，1&lt;n&lt;1,000,000,000输出：每组数据输出一个整数，即为f(n)对1,000,000,007取模后的结果分析：从题目中可以看出，数据范围比较大，如果是用递归或者递推方式写，肯定会超时，所以我们应该要考虑其他的方法。我们就可以考虑快速幂的方法。不过，这道题要用到矩阵乘法，用矩阵快速幂。代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#define MOD 1000000007using namespace std;typedef long long ll;struct matrix{ ll m[3][3];}Mat,unit;ll a[3]={0,1,2};matrix multi(matrix a,matrix b){ matrix res; ll x; ll i,j,k; for(i=0;i&lt;3;i++){ for(j=0;j&lt;3;j++){ x=0; for(k=0;k&lt;3;k++){ x=(x+((ll)a.m[i][k]*(ll)b.m[k][j]))%MOD; } res.m[i][j]=x%MOD; } } return res;}void Init(){ Mat.m[0][0]=2;Mat.m[0][1]=1;Mat.m[0][2]=0; Mat.m[1][0]=1;Mat.m[1][1]=0;Mat.m[1][2]=1; Mat.m[2][0]=0;Mat.m[2][1]=0;Mat.m[2][2]=0; for(int i=0;i&lt;3;i++){ unit.m[i][i]=1; }}matrix pow_matrix(matrix a,ll n){ matrix res=unit; while(n){ if(n&amp;1)res=multi(res,a); a=multi(a,a); n=n&gt;&gt;1; } return res;}ll Feibonaqi(ll n){ if(n==0)return a[0]; if(n==1)return a[1]; if(n==2)return a[2]; matrix res=pow_matrix(Mat,n-2); return (a[2]*res.m[0][0]+a[1]*res.m[1][0])%MOD;}int main(){ Init(); ll n; while(cin&gt;&gt;n){ cout&lt;&lt;Feibonaqi(n)&lt;&lt;endl; }} a2 a1 a0=[ 2 , 1 , 0 ]，Feibonaqi前三项Mat:根据Feibonaqi推出的矩阵(可以写成2X2的矩阵，a也可以改成1X2的) 2 1 0 1 0 0 0 0 0 a*Matn-2得到的一行三列的矩阵的第0项就是要求的值","link":"/2020/05/01/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"title":"排序算法","text":"1、冒泡排序：冒泡排序就像它名字一样，冒泡，就像水里的气泡一样往上冒，通过多次冒泡，可以把小的往前，也可把大的往后，使得一组数据大小有序排列，举个例子：待排 ：4 3 2 5 1 3 2 4 1 5 2 3 1 4 5 2 1 3 4 5 1 2 3 4 5 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;void sort(int a[],int n)//冒泡{ int i,j; for(i=0;i&lt;n;i++) //此循环执行n次，依次将最大数，次大数······放到后面，从而实现从小到大排序 { for(j=0;j&lt;n-i-1;j++) //此循环将较大的数放到后面，大数就像冒泡一样往后冒 { if(a[j]&gt;a[j+1]) { int temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; } } }}int main(){ int n,i; scanf(\"%d\",&amp;n); int a[n]; for(i=0;i&lt;n;i++) { scanf(\"%d\",&amp;a[i]); } sort(a,n); for(i=0;i&lt;n;i++) { printf(\"%d \",a[i]); } return 0;} 测试 2、选择排序：选择排序是每次通过循环比较后，记下最大或者最小数的位置，然后交换。举个例子：4 3 2 5 1（记下最小数位置） 1 3 2 5 4 1最小，1和4交换 1 2 3 5 4 在后四个数中2最小，2和3交换 1 2 3 5 4 在后三个数中3最小，位置不变 1 2 3 4 5 在后两个数中4最小，4和5交换 代码：12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;void SelSort(int a[],int n)//选择{ int i,j; for(i=0;i&lt;n-1;i++) { int minIndex=i; for(j=i+1;j&lt;n;j++) { if(a[minIndex]&gt;a[j]) { minIndex=j; } } int temp=a[i]; a[i]=a[minIndex]; a[minIndex]=temp; }}int main(){ int n,i; scanf(\"%d\",&amp;n); int a[n]; for(i=0;i&lt;n;i++) { scanf(\"%d\",&amp;a[i]); } SelSort(a,n); for(i=0;i&lt;n;i++) { printf(\"%d \",a[i]); } return 0;} 测试 3、插入排序：插入排序，就像咱们斗地主一样，把大的放一边，小的放一边，摸起一张牌后，要找到适合它的位置插入。举个例子：4 3 2 5 1 4 3 2 5 1 只有4，位置不变 3 4 2 5 1 3比4小，插到四前面 2 3 4 5 1 2比3、4小，插到最前面 2 3 4 5 1 5比前面的数都大，不变 1 2 3 4 5 1最小，插到最前面注意：这里的插入是通过一个数一个数的移动完成的 代码：1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;void InsertSort(int a[],int n)//插入 { int i,j; for(i=1;i&lt;n;i++) { for(j=i-1;j&gt;=0&amp;&amp;a[j]&gt;a[j+1];j--)//寻找合适的插入位置，通过一个数一个数的移动完成的 { int temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; } }}int main(){ int n,i; scanf(\"%d\",&amp;n); int a[n]; for(i=0;i&lt;n;i++) { scanf(\"%d\",&amp;a[i]); } InsertSort(a,n); for(i=0;i&lt;n;i++) { printf(\"%d \",a[i]); } return 0;} 测试： 4、归并排序：归并排序涉及到递归（不懂得小伙伴自己去查查，自己调自己了）需要开辟一个辅助数组来存数据；每次归并一部分，慢慢扩大范围，使得整组数据有序。还是举个例子：4 3 2 5 1 被划分为 4 3 2 、5 1两部分 再划分 4 3 、 2 、 5、 1四部分 4 3再划分为 4 、3两部分 （实际上并不是这样，只是为了方便理解，实际是先把左边划分归并完后，再来划分归并右边的） 接下来开始归并 4 和 3归并 3小变成 3 4 3 4和2归并 2小变成 2 3 4 5和1 归并 变成 1 5 2 3 4和 1 5归并谁小谁放前面 1 2 3 4 5完成这个理解起来稍微复杂一点，但是他的时间复杂度比前三个都小。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;stdio.h&gt;void MergeSort(int a[],int L,int R)//归并排序{ if(L==R)return; int mid=(L+R)/2; MergeSort(a,L,mid); //对半分，先使得左边有序， MergeSort(a,mid+1,R); //再使得右边有序，最后使得整体有序 int temp[R-L+1]; //开一个辅助数组 int i=0; int p1=L,p2=mid+1; while(p1&lt;=mid&amp;&amp;p2&lt;=R) //归并过程 { temp[i++]=a[p1]&lt;a[p2]?a[p1++]:a[p2++]; //谁小把谁放进辅助数组 } while(p1&lt;=mid) //接下来这两个循环是把没归并完的数放入辅助数组 { temp[i++]=a[p1++]; } while(p2&lt;=R) { temp[i++]=a[p2++]; } for(i=0;i&lt;=R-L;i++) //把辅助数组的值复制给原数组 { a[L+i]=temp[i]; //printf(\"%d \",temp[i]); 此处可打印观看归并过程 } //printf(\"\\n\");}int main(){ int n,i; scanf(\"%d\",&amp;n); int a[n]; for(i=0;i&lt;n;i++) { scanf(\"%d\",&amp;a[i]); } MergeSort(a,0,n-1); for(i=0;i&lt;n;i++) { printf(\"%d \",a[i]); } return 0;} 测试： 这是我的第一篇博客，学习ing，如有不足，望多担待","link":"/2019/11/17/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%86%92%E6%B3%A1%E3%80%81%E9%80%89%E6%8B%A9%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E5%BD%92%E5%B9%B6%EF%BC%89/"},{"title":"猪鸭计划","text":"鸭鸭目标：​ 鸭鸭校招冲美团、小红书、拼多多，秋招不要瞎投，春招有把握再投，争取一把上岸，最优成都美团。 猪鸭毕业旅游鸭鸭要存钱，每天省着花，剩下来的钱要存起来，用作毕业旅游基金。 因为鸭鸭没有去过海边，目的地鸭鸭先暂定厦门、鼓浪屿或者三亚，后面再和猪猪商量，嘿嘿。 猪猪考研全心全意支持猪猪考研，不可以惹猪猪生气，猪猪加油","link":"/2020/09/11/%E7%8C%AA%E9%B8%AD%E8%AE%A1%E5%88%92/"}],"tags":[{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"二叉树的遍历","slug":"二叉树的遍历","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序算法","slug":"排序算法","link":"/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"猪鸭计划","slug":"猪鸭计划","link":"/tags/%E7%8C%AA%E9%B8%AD%E8%AE%A1%E5%88%92/"}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"猪猪","slug":"猪猪","link":"/categories/%E7%8C%AA%E7%8C%AA/"}]}